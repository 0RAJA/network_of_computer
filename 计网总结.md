# 计网总结

## OSI七层模型

OSI七层模型：应用层、表示层、会话层、运输层、网络层、数据链路层、物理层

TCP/IP 四层模型： 应用层、运输层、网络层、网络接口层

五层模型：应用层、运输层、网络层、数据链路层、物理层

### 应用层，表示层，会话层

1. 应用层：负责给应用程序提供统一的接口。

2. 表示层：主要负责数据格式的转换，压缩与解压缩，加密与解密，为系统提供特殊的数据处理能力，负责把数据转换成兼容另一个系统能识别的格式。
3. 会话层：是在发送方和接收方之间进行通信时创建、维持、之后终止或断开连接的地方，与电话通话有点相似。主要功能是对会话进行管理和控制，保证会话的可靠传输。

但是实际上表示层和会话层并未完全的独立实现，不同的应用程序有大同小异的会话表示需求，这些代码并不能完全抽象出独立的会话层、表示层。现在各个应用层协议已经比较完美并符合自我的实现了会话层和表示层，自身已经完成了上三层协议，因此在实际工业层面的实现中，将上三层协议划分在一起，称之为应用层。

主要用到的协议有HTTP、FTP、Telnet、DNS、SMTP

### 传输层

该层的协议为应用进程提供端到端的传输服务。主要用到的协议有TCP，UDP

### 网络层

在网络中进行通信的两个计算机之间回经过很多的通信子网。网络层的作用就是选择合适的网间路由和交换节点进行路由转发，确保数据及时送达。网络层把运输层产生的报文段封装成分组和包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫IP数据报，简称数据报。

主要协议有IP、ICMP 。

### 数据链路层

主机之间通信总是在一段一段的链路上进行传送的，而数据链路层就是作用在这一个个链路上的协议。两个相邻节点之间传送数据时，数据链路层将网络层传来的IP数据报组装成帧，在两个相邻节点之间的链路上传送。每一帧包括数据和必要的控制信息。

数据的封帧和差错检测，以及 MAC 寻址；

### 物理层

物理层上所传输的数据单位是比特。

负责在物理网络中传输数据帧。

## 网络请求流程

![简单的网络模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/2.jpg)

### 应用层

#### HTTP

1. 解析URL 获取请求信息

   ![URL 解析](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/3.jpg)

2. 生成HTTP请求报文

   需要：**请求方法，URL，版本，请求头，请求体**

   ![HTTP 的消息格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/4.jpg)

3. DNS查询IP

   域名解析：本地DNS->根->顶级->权威(解析结果的出处找到IP)->本地DNS->应用程序，亲力亲为。

   通过DNS服务器将目标域名转换为目标IP(浏览器域名缓存->操作系统缓存->hosts文件->本地DNS服务器)

生成HTTP报文后将传输工作通过Socket给协议栈。

#### Socket

​	是应用程序中的编程接口API，是对传输层的抽象封装，可以更方便地调用TCP/IP协议的功能。

1. 创建->向TCP/IP协议栈声明端口占用。
2. 连接->抽象TCP连接建立，IP+端口。
3. 断开->抽象TCP挥手。
4. 删除->为了防止服务器重传的FIN，可能需要等待一会再删除。

#### 协议栈

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg)

上半部分TCP/IP收发数据，下半部分IP协议（切片，路由），IP中还存在ICMP（告知传输错误），ARP协议（IP换MAC）。

IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。

### 传输层

HTTP基于TCP协议进行传输。

#### TCP

![TCP 包头格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/8.jpg)

需要：

1. 源端口，目标端口
2. 包序号：解决包乱序
3. 确认号：确认是否送达，解决丢包。
4. 状态位：`SYN`发起连接，`ACK`回复，`RST`重连，`FIN`结束。
5. 窗口大小：流量控制，调整速率。
6. 拥塞控制：控制速率。

查看tcp连接状态：`netstat -napt`

功能：

1. 三次握手：保证双方都有发送和接收的能力
2. 分割数据：HTTP长度超过MSS进行分片

TCP报文生成后交给网络层处理。

### 网络层

#### IP

TCP在连接，收发，断开等操作时，都需要IP模块将数据封装为网络包进行通信。

IP报文：

![IP 包头格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/14.jpg)

需要：

1. 源IP，目标IP

   存在多个网卡时，通过路由表规则判断选择哪个IP。即选择和目标IP处于同一网段的网卡IP作为源IP，如果没有就选择路由IP，后续把包发给路由器。

2. 协议号：TCP

### 网络接口层

生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 **MAC 头部**。

#### MAC

![MAC 包头格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/18.jpg)

MAC头部是以太网使用的头部，包含：

1. 源和目标MAC地址

   源MAC在本机ROM中。目标MAC则需要通过ARP进行获取。先看ARP缓存，没有就对当前子网中所有设备广播ARP协议，然后获取到MAC。如果目标和自己不在同一网段，就ARP网关，获取对方MAC地址，把数据发给网关。

2. 协议类型：TCP/IP中一般只有IP和ARP协议。

#### 网卡

网卡驱动程序控制网卡将网络包转换为电信号。

网卡驱动获取网络包后会将其**复制**到网卡内的缓存区中，接着会在其**开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列**。

![数据包](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.png)

#### linux下发送网络包：

1. 应用层：调用Socket发送数据包，陷入内核态，申请内核sk_buf并拷贝，加入发送缓冲区。

   传输层：从发送缓冲区取sk_buf按照协议栈处理（如果是TCP就拷贝一个新的sk_buf（丢失重传用）,sk_buf中data指针指向协议首部）。

   网络层：获取IP，填充IP，分片

   网络接口层：ARP获取MAC，填充帧头帧尾。把sk_buf放在发送队列，触发软中断。

2. 网卡驱动程序从发送队列读取sk_buf挂在循环缓冲区。

3. 通过DMA读取数据进行发送。

4. 最后通过硬中断清理sk_buf和循环缓冲区。

#### linux下接收网络包：

1. 网卡收到网络包后，通过DMA将网络包写入到指定内存地址（环形缓冲区），触发硬件中断

2. CPU执行对应中断处理函数：屏蔽中断（数据直接写入缓冲区），触发软中断

3. 内核中单独一个线程收到软中断后来轮训处理数据，从环形缓冲区中读一个数据帧(sk_buff)，交给网络协议栈处理。

4. 网络接口层：判断报文合法性，然后去除帧头帧尾，根据IP协议类型给网络层

   网络层：去除IP包判断下一步走向，如果是本机就查看上一层协议（TCP/UDP），去除IP头，给传输层

   传输层：取出TCP或UDP头，找到目标Socket，把数据放到Socket内核接收缓冲区。

   应用层：调用Scoket接口将内核缓冲区中的数据靠拷贝到应用层缓冲区，唤醒用户进程。

## 应用层协议

### HTTP

#### 什么是HTTP

超文本传输协议，是一个应用层协议。HTTP是一个在计算机领域内，专门在两点之间传输文字、图片、音视频等超文本数据的约定和规范。

- HTTP报文大致可以分为**报文首部**+**报文主体**，首部和主体由CRLS(一行空格)来区分。
- 报文分为**请求报文**和**响应报文**两种，HTTP的这两种报文都有三部分组成：**开始行**、**首部行**、**实体主体**
  - **开始行用于区分两种报文**
  - **首部行是由首部字段名+值组成**，每个首部行在结束时都有CRLS
  - 首部行和实体之间也有空行

#### HTTP协议内容

![HTTP 的消息格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/4.jpg)

##### 请求报文

- 请求报文由三部分组成，分别是**请求行**、**请求头、请求正文**

- 请求方法：

  ![img](https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180810112625596-2103906128.png)

  是否 安全，幂等？

  1. 安全：请求方法不会破坏服务器上资源
  2. 幂等：多次执行相同操作，结果相同。

##### 响应报文

- 响应报文也是由三个部分组成，分别是：**状态行、响应头、响应正文**
- 状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。
- 状态码有：
  - `200 OK` 客户端请求成功
  - `301 Moved Permanently` 请求永久重定向
  - `302 Moved Temporarily` 请求临时重定向
  - `304 Not Modified` 文件未修改，可以直接使用缓存的文件。
  - `400 Bad Request` 由于客户端请求有语法错误，不能被服务器所理解。
  - `403 Forbidden` 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因
  - `404 Not Found` 请求的资源不存在，例如，输入了错误的URL
  - `500 Internal Server Error` 服务器发生不可预期的错误，导致无法完成客户端的请求。
  - `503 Service Unavailable` 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。

#### HTTP 缓存

##### 强制缓存（浏览器）

如果浏览器判断缓存未过期就用本地

![image-20220929223409644](https://raja-img.oss-cn-hangzhou.aliyuncs.com/img/image-20220929223409644.png)

利用两个HTTP响应头来表示有效期

`Cache-Control` 相对时间（优先） 和 `Expires`过期时间

##### 协商缓存（服务器）

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98etag.png)

**协商缓存这两个字段都需要配合强制缓存中 Cache-control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**。

#### HTTP1.0和HTTP1.1

##### HTTP1.0

1. 优点

   1. 简单

      报文格式：首部+body，首部信息也是kv形式。

   2. 灵活易拓展

      请求方法，URI和URL，状态码，头部字段等没有硬性要求。且因为其工作在应用层，下层可以随意替换。

   3. 应用广泛，跨平台

2. 缺点：

   1. 无状态：关联性操作很麻烦。
   2. 明文传输：易窃听
   3. 不验证通信方的身份，因此有可能遭遇伪装
   4. 无法证明报文的完整性，所以有可能已遭篡改

##### HTTP1.1

相比于1.0在性能上的改进，使用长链接，支持pipe。

连接方式：减少TCP建立次数

1. 短连接：每一个 HTTP 请求之前都会有一次 TCP 握手，耗费时间。

2. 长连接：一个长连接会保持一段时间，重复用于发送一系列请求，节省了新建 TCP 连接握手的时间，还可以利用 TCP 的性能增强能力。当然这个连接也不会一直保留着：连接在空闲一段时间后会被关闭。

   （支持pipe传输成为可能）

3. 流水线：流水线是在同一条长连接上发出连续的请求，而不用等待应答返回。这样可以避免连接延迟。

   但是服务器必须按照发送请求的顺序来响应这些请求。（容易出现响应的队头阻塞）

   与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。（容易出现请求的队头阻塞）

#### HTTP1.1优化

##### 缓存：避免发送HTTP请求

第一次请求把`url-资源`缓存在本地，同时保存过期时间。过期就携带缓存摘要重新请求，服务器比较相同则返回304,

##### 减少HTTP请求次数

1. 重定向交给代理服务器

   而且当代理服务器知晓了重定向规则后，可以进一步减少消息传递次数

   依赖于重定向码的拓展

   ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E9%87%8D%E5%AE%9A%E5%90%91%E5%93%8D%E5%BA%94%E7%A0%81.png)

2. 合并请求

   可以通过将多个小资源合并为一个大资源来请求。或者直接把数据一起发回来。

   1. 减少重复的http头部信息
   2. 减少TCP握手次数

   但是如果一个资源发生改变，需要重新请求所有数据。

3. 延迟发送

   按需请求数据。

##### 减少响应数据大小。

客户端：`Accept-Encoding`字段告知支持的加密方式。

服务端：`content-encoding` 告知加密方式。

#### HTTPS

`HTTP1.1`明文，不验证身份，不验证数据完整性。

`HTTPS`在应用层和传输层之间加入`SSL/TLS`协议保证安全性。

![HTTP 与 HTTPS 网络层](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/19-HTTPS%E4%B8%8EHTTP.png)

1. 信息加密：混合加密（对称和非对称加密）

   通信建立前采用非对称加密交换会话密钥，后续使用会话密钥对称加密数据。

   私钥加密，公钥解密：不会被修改（加密摘要）

   公钥加密，私钥解密：保证数据传输（加密信息）

2. 校验机制：摘要算法（服务端私钥加密）

3. 身份证书：服务器公钥给CA机构，防止被伪造

##### SSL/TLS协议

1. 客户端向服务端索要并验证服务器`公钥`。
2. 协商`会话密钥`
3. 采用`会话密钥`通信

##### RSA四次握手

用于计算`会话密钥`

1. 客户端请求：

   1. 支持`TLS/SSL协议`版本
   2. 客户端`随机数A`（公开）
   3. 客户端支持的加密算法（RSA）

2. 服务端请求：

   1. 确认`SSL/TLS`版本
   2. 服务端`随机数B`（公开）
   3. 确认加密算法
   4. 服务器证书

3. 客户端响应：

   先验证证书获取`服务器公钥`，生成`随机数C`，计算出`会话密钥`

   1. 公钥加密`随机数C`（加密信息）
   2. 标志加密
   3. 通信摘要

4. 服务器响应：

   根据`ABC`计算出`会话密钥`

   1. 标志加密
   2. 通信摘要

缺陷：不支持前向加密：服务器私钥泄漏后，之前的数据都可以解密。

##### ECDHE 握手

确认会话密钥算法：

> 双方确定`圆锥曲线`和`基点G`
>
> 客户端随机生成密钥`d1`，计算出公钥`Q1 = d1 * G`
>
> 服务端随机生成密钥`d2`，计算出公钥`Q2 = d2 * G`
>
> 客户端获取`Q2`,计算出`(x1,y1) = d1*Q2`
>
> 服务端获取`Q1`,计算出`(x2,y2) = d2*Q1`
>
> 因为`d1*Q2 = d1*d2*G = d2*Q1`，可以得到`x1 = x2`相同
>
> 所以`x`就是确定的会话密钥

1. 客户端：

   1. `Client Hello`
      1. 支持`TLS/SSL协议`版本
      2. 客户端`随机数X`（公开）
      3. 客户端支持的加密算法（ECDHE）

2. 服务端：

   1. `Server Hello`
      1. 确认`SSL/TLS`版本
      2. 服务端`随机数Y`（公开）
      3. 确认加密算法
         1. 密钥协商算法：ECDHE
         2. 签名算法：RSA
         3. 握手后通信使用AES对称算法
         4. 摘要算法

   2. `Certificate`：证书消息
   3. `Server Key Exchange`：选取的`椭圆曲线和基点G`
      1. 选好椭圆曲线
      2. 生成随机数`b`作为私钥,保留本地
      3. 服务器公钥`B`给服务端
      4. RSA摘要算法签名公钥（服务器私钥）。

   4. `Server Hello Done`：结束

3. 客户端

   客户端收到证书去CA校验并获取服务器公钥，使用服务器公钥验证公钥`B`。

   客户端生成`a`作为客户端私钥，椭圆曲线公钥`A`

   客户端计算出`会话密钥x`+客户端`随机数X`+服务端`随机数Y` = `会话密钥`

   1. `Client Key Exchange`

      客户端公钥`A`

   2. `Change Cipher Spec`：后续采用加密通信

   3. `Encrypted Handshake Message`：之前发送数据的摘要，使用会话密钥加密（验证是否可用）。

4. 服务端

   服务端拿到公钥`A`，算出`x`。

   服务端计算出`椭圆曲线x`+客户端`随机数X`+服务端`随机数Y`= `会话密钥`

   1. `Change Cipher Spec`：后续采用加密通信
   2. `Encrypted Handshake Message`：之前发送数据的加密摘要

提升：

1. 往返时间减少

   客户端可以在第三次握手后计算出密钥之后就发送数据，将2RTT减少为1RTT。

2. 重连恢复

   1. 会话复用Session：

      TLS握手后双方缓存`会话密钥`和`SessionID`标记这次TLS握手

      缺点：

      1. 服务端内存压力增大
      2. 服务器负载均衡，不一定命中缓存

   2. 把`会话密钥`加密成`token`给客户端保存

      注：`TLS1.3`直接第一次就把数据和`会话token`发送给服务端

      缺点：容易被截获（需要设置合理的过期时间）

##### 中间人问题

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.png)

相当于客户端和中间人加密通信，中间人和服务器加密通信。

但是前提是我们可以从CA解析中间人提供的自己的服务器证书。

中间人能够解密数据需要：

1. 去服务端拿到私钥
2. 去CA签发私钥
3. 自己签发证书，需要被浏览器信任
   1. 本机中病毒，添加根证书
   2. 信任不受保护的连接

保护方式：可以采用双向认证。

#### HTTP2

![HTT/1 ~ HTTP/2](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/25-HTTP2.png)

##### 基于HTTPS

##### HPACK 头部压缩

使用`HPACK算法`压缩头部，共同维护头信息表，每次发送可以只发送索引号

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/index.png)

`1`表示表中存在，剩下位数可以表示对应编号。

1. 静态字典

   存放常见的字段和对应的值

   ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E9%9D%99%E6%80%81%E8%A1%A8.png)

   如果头部字段属于静态表范围，并且 Value 是变化，那么它的 HTTP/2 头部前 2 位固定为 `01`

   ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E9%9D%99%E6%80%81%E5%A4%B4%E9%83%A8.png)

   第二个字节的首个比特位表示 Value 是否经过 Huffman 编码，剩余的 7 位表示 Value 的长度，比如这次例子的第二个字节为 `10000110`，首位比特位为 1 就代表 Value 字符串是经过 Huffman 编码的，经过 Huffman 编码的 Value 长度为 6。

   ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E9%9D%99%E6%80%81%E5%A4%B4%E9%83%A82.png)

2. 动态字典

   不在静态表中的字段就在huffman编码之后添加到双方动态表中，之后每次只需要发这个字段对应表中的下标即可。

   限制：

   1. 同一个连接下，相同的字段名
   2. 双方的字典占用会越来越大

##### 二进制帧

将原本HTTP纯文本更改为二进制帧形式（头信息帧+数据帧），计算机可以直接解析二进制数据。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7.png)

二进制帧结构

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E5%B8%A7%E6%A0%BC%E5%BC%8F.png)

帧类型：控制帧，数据帧

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E5%B8%A7%E7%B1%BB%E5%9E%8B.png)

标志位：控制信息

- **END_HEADERS** 表示头数据结束标志，相当于 HTTP/1 里头后的空行（“\r\n”）；
- **END_Stream** 表示单方向数据发送结束，后续不会再有数据帧。
- **PRIORITY** 表示流的优先级；

流标志符（StreamID）：

它的作用是用来标识该 Frame 属于哪个 Stream，接收方可以根据这个信息从乱序的帧里找到相同 Stream ID 的帧，从而有序组装信息。

最后面就是**帧数据**了，它存放的是通过 **HPACK 算法**压缩过的 HTTP 头部或包体

##### 并发传输

引入`stram`概念。

1. 1个TCP中有多个`Stream`（一个HTTP的请求与响应都在一个`Stream`）
2. 一个`Stream`包含多个`Message` (一个请求或者响应)
3. 一个`Message`里面存着很多`二进制帧`，一个帧存一个二进制`头部`或`包体`

不同`Stream`的`frame`可以乱序发送（frame中有stream id，可以被组装），但是一个`Stream`中的`frame`是顺序的。一个`frame`丢失则会阻塞后面的`frame`即其他响应。

客户端主动建立的`Stream ID`为奇数

服务端主动建立的`Stream ID`为偶数

`Stream ID`有限，用完需要断开TCP连接。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http2%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.jpeg)

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/stream.png)

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/stream2.png)

##### 服务器推送

在 Nginx 中，如果你希望客户端访问 /test.html 时，服务器直接推送 /test.css，那么可以这么配置：

```nginx
location /test.html { 
  http2_push /test.css; 
}
```

客户端发起的请求，必须使用的是奇数号 Stream，服务器主动的推送，使用的是偶数号 Stream。服务器在推送资源时，会通过 `PUSH_PROMISE` 帧传输 HTTP 头部，并通过帧中的 `Promised Stream ID` 字段告知客户端，接下来会在哪个偶数号 Stream 中发送包体。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/push2.png)



##### TCP队头阻塞

存在TCP层次的队头阻塞。

HTTP基于TCP，TCP是字节流协议，TCP层必须保证收到的字节数是完整且连续的，内核才会将内核缓冲区中的数据返回给应用。所以只要存在一个字节数据丢失，剩下的数据都会阻塞在内核缓冲区。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/http2%E9%98%BB%E5%A1%9E.jpeg)

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http3/tcp%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E.gif)

packetID类似于tcp的序列号，其中一个丢失需要等待重传才会把数据给应用。

#### HTTP3

HTTP1.1 解决了发送方队头阻塞，但是存在服务端队头阻塞

HTTP2 解决了HTTP队头阻塞，但是丢包会阻塞所有HTTP请求。

所以HTTP3.0把TCP换成UDP

![HTTP/1 ~ HTTP/3](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/27-HTTP3.png)

##### QUIC

UDP不可靠，通过QUIC来实现可靠传输

###### 无队头阻塞

**当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题**。

但是QUIC保证数据包的可靠性，每个数据包会有一个序号，即使该`Stream`中一个数据包丢失，该`Stream`中其他数据包也需要等待。

QUIC协议建立在UDP基础上，所以`Stream`之间彼此独立。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/quic%E6%97%A0%E9%98%BB%E5%A1%9E.jpeg)

###### 更快的连接建立

HTTP1或HTTP2，TLS和TCP是分层的，需要分批次去握手。

HTTP3中QUIC携带TLS，只需要1个往返时间就可以同时建立连接和密钥协商

![TCP HTTPS（TLS/1.3） 和 QUIC HTTPS ](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/28-HTTP3%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0.png)

甚至在第二次连接时，数据包就可以和QUIC（连接信息+TLS信息）一起发送。

同时重新建立会话时间也很短

![img](https://img-blog.csdnimg.cn/4cad213f5125432693e0e2a512c2d1a1.png)

###### 连接迁移

TCP使用`源IP，源端口，目标IP，目标端口`确定一条连接

在切换网络时需要重新建立TCP连接

QUIC通过`连接ID+TLS密钥等`确定一条连接。

### RPC

TCP采用无边界的数据流，需要应用层来定义消息格式来确认消息边界。

RPC和HTTP都是在应用层实现的协议或方法，RPC用于远程过程调用，属于一种方法，可以像调用本地方法一样调用远程方法，RPC在中间屏蔽了很多细节。

#### 服务发现

建立连接需要获取目标`IP+端口`，获取的过程就是服务发现。

RPC会通过中间服务商去保存相关信息，HTTP则通过DNS服务去获取`IP`。

#### 底层连接

HTTP1.1采用复用TCP长连接

RPC也是采用TCP长连接，同时会存在连接池来缓存连接。

#### 传输内容

同时通过TCP进行传输，所以都是消息头+消息体

HTTP1.1头部冗余，包体明文消耗大。

RPC可以根据好的协议来序列化结构体信息等。

但是HTTP2性能比RPC还好，所以很多RPC协议都底层采用HTTP2

## 传输层协议

### TCP

### UDP

